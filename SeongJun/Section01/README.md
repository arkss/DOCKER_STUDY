# 도커 기본

## 도커를 쓰는 이유

* 환경에 따라 ( OS, 깔려있는 패키지 버전 등등 .. ) 여러 에러가 발생, 설치과정이 복잡 이걸 단순화

## 도커란 무엇인가?

컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구, 컨테이너 기반의 오픈소스 가상화 플랫폼

서버에서 컨테이너 - 프로그램, 실행환경을 컨테이너로 추상화하고 동일 인터페이스로 배포, 관리를 단순하게

## 도커 이미지와 도커 컨테이너 정의

* 컨테이너
  * 코드와 모든 종속성을 패키지화해서 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 표준 단위
  * 소프트웨어를 환경으로부터 격리시키고 개발과 스테이징 차이에도 균일하게 작동하도록 보장함

* 이미지
  * 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행가능한 패키지
  * 런타임에 컨테이너가 되고, 도커 컨테이너는 도커 엔진에서 실행될 때 이미지에서 컨테이너가 됨

## 도커를 사용할 때의 흐름

1. docker cli에 커맨드 입력
2. 도커 서버가 그 커맨드를 받아서 이미지 생성/ 컨테이너 실행 등을 함

![image](https://user-images.githubusercontent.com/26623194/129467482-e600aa7e-2d97-4a8f-8742-197de856a859.png)

* docker run hello-world -> 도커 클라이언트
* 도커 서버... ? / 이미지 보관 장소에서 이미지 확인
* 없으니까 도커 허브에서 갖고옴

## 도커와 기존의 가상화 기술과의 차이를 통한 컨테이너 이해

* ### 가상화 기술이 나오기 전

  * 한대의 서버를 하나의 용도로만 사용
  * 난는 서버 공간 그대로 방치
  * 하나의 서버에 하나의 운영체제, 하나의 프로그램만 운영
  * 안정적이지만 비효율적이다

* ### 하이퍼 바이저 기반의 가상화 출현

  * 논리적으로 공간을 분할하여 VM이라는 독립적인 가상 환경의 서버 이용 가능
  * 하이퍼 바이저는 호스트 시스템에서 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어
  * 하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간관리자이다.
  * 네이티브 하이퍼 바이저
    * 하드웨어를 직접 제어하여 자원 효율적으로 사용 가능
    * 별도의 호스트 OS가 없으므로 오버헤드가 적다
    * 하드웨어 드라이버 셋팅해야 하므로 설치가 어렵다
  * 호스트형 하이퍼 바이저가 있음 
    * 호스트 OS 위에서 실행됨
    * 하드웨어 자원을 VM내부의 게스트 OS에 에뮬레이트 하는 방식으로 오버헤드가 크다.
    * 게스트 OS 종류에대한 제약이 없고 구현이 다소 쉽다.
    * 많이 쓰는 방식!
    * 논리적으로 분리 되어 있음

* ### 컨테이너 가상화 기술

  * ![image](https://user-images.githubusercontent.com/26623194/129467573-0f557e31-0708-49f7-8a94-a7e381853a70.png)

  * 차이?

    * 기본 하드웨어에서 격리된 환경 내에 어플리케이션을 배치한다는건 동일 - **얼마나 격리시키는지의 차이**

    * 컨테이너는 하이퍼바이저와 게스트OS를 필요하지 않으므로 더 가볍다.

    * 어플리케이션을 실행할 때

      * 컨테이너 방식에서는 호스트 OS위에 어플리케이션의 실행 패키지인 이미지를 배포하기만 하면 됨
      * VM은 VM을 띄우고 자원을 할당하고, 게스트OS를 부팅하여 실행

    * **도커 컨테이너**에서 돌아가는 어플리케이션은 컨테이너가 제공하는 격리 기능 내부에 샌드박스가 있지만 여전히 같은 호스트의 다른 컨테이너와 동일한 커널을 공유한다.
      결과적으로 컨테이너 내부에서 실행되는 프로세스는 호스트 시스템에서 볼 수 있다.

    * **VM** 과 함께 VM 내부에서 실행되는 모든 것은 호스트 운영 체제 또는 하이퍼바이저와 독립되어있다.
      가상 머신 플랫폼은 특정 VM에 대한 가상화 프로세스를 관리하기 위해 프로세스를 시작하고, 호스트 시스템은 그것의 하드웨어 자원의 일부를 VM에 할당한다.
      그러나 VM과 근본적으로 다른 것은 시작 시간에 이 VM환경을 위해 새롭고 이 특정 VM만을 위한 커널을 부팅하고, OS 프로세스 셋을 시작한다는 것
      이 때문에 큼

      

  ### 어떻게 도커 컨테이너를 격리?

  * C group

    * CPU, 메모리, Network HD i/o 등 프로레스 그룹의 시스템 리소스 사용량을 관리

      => 어떤 어플이 사용량이 너무 많다면 C group에 집어넣어서 사용 리소스 제한 가능

  * 네임스페이스
    * 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술,
    * 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술
  * ![image](https://user-images.githubusercontent.com/26623194/129467762-285648f8-eb61-41e3-9309-b48e2fe68a1f.png)

![image-20210815140646845](/Users/seongjunkim/Library/Application Support/typora-user-images/image-20210815140646845.png)

* 커널공유하고 아래는 CGroup / NameSpace로 ?

## 이미지로 컨테이너 만들기

* 이미지는 응용 프로그램을 실행하는데 필요한 모든 것을 포함하고있습니다.
  1. 시작시 실행될 명령어 - `run kakaotalk`
  2. 파일 스냅샷 - 카카오톡 파일

## Cgroup, 네임스페이스를 쓸수 있는 이유

* C group, namespace 은 리눅스 환경?
* ![image](https://user-images.githubusercontent.com/26623194/129467892-d13bdffa-2682-444a-9771-2f2b23f53112.png)
* 리눅스 VM이 깔려있음

